INCLUDE common.inc

extern g_inputHandle :DWORD
extern g_coord :DWORD
extern g_currentActiveBuffer :DWORD
extern g_pendingBuffer :DWORD

PrintStrs PROTO
SwapBuffer PROTO
ShowLinkList PROTO

.data
MapSize = 26
map BYTE MapSize*MapSize DUP(0)
mapRawData BYTE MapSize DUP(2 * MapSize + 1 DUP(' '))
mapStrs DWORD MapSize DUP(0) ; char**
mapItem BYTE "■",0
snakeHead BYTE "■",0
snakeBody BYTE "●",0
food BYTE "□",0
mapCoord DWORD 0
linkHead DWORD -1
linkListData DWORD MapSize * MapSize DUP(0)
linkList DWORD MapSize * MapSize DUP(-1)
curLinkListLength DWORD 0

.code

InitMap PROC
	push ebp
	mov ebp,esp
	push esi
	push edi
	sub esp,10h
	mov DWORD PTR [ebp - 4],0; mapStrs
	mov eax,OFFSET mapStrs
	mov DWORD PTR [ebp - 4],eax
	; fill map and mapRawData row
	lea esi,map ; [0][0~MapSize - 1]
	lea edi,map
	add edi,(MapSize - 1) * MapSize ; [MapSize - 1][0~MapSize - 1]
	lea eax,mapRawData ; [0][0~MapSize - 1]
	lea ebx,mapRawData
	add ebx,(MapSize - 1) * (2 * MapSize + 1) ; [MapSize - 1][0~MapSize - 1]
	mov ecx,MapSize
FILLROW:
	mov BYTE PTR [esi],1
	mov BYTE PTR [edi],1
	mov dx,WORD PTR [mapItem]
	mov WORD PTR [eax],dx
	mov WORD PTR [ebx],dx
	inc esi
	inc edi
	add eax,2
	add ebx,2
	LOOP FILLROW
	; fill map and mapRawData column
	lea esi,map; map[0~MapSize - 1][0]
	lea edi,map
	add edi,MapSize - 1 ; map[0~MapSize - 1][MapSize - 1]
	lea eax,mapRawData; mapRawData[0~MapSize - 1][0]
	lea ebx,mapRawData
	add ebx,2 * MapSize - 2 ; mapRawData[0~ 2 * MapSize - 1][MapSize - 1]
	mov ecx,MapSize
FILLCOL:
	mov BYTE PTR [esi],1
	mov BYTE PTR [edi],1
	mov dx,WORD PTR [mapItem]
	mov WORD PTR [eax],dx
	mov WORD PTR [ebx],dx
	add esi,MapSize
	add edi,MapSize
	mov edx,ebx
	add edx,2
	mov BYTE PTR [edx],0 ; add '\0'
	mov edx,DWORD PTR [ebp - 4]
	mov DWORD PTR [edx],eax
	add eax,2 * MapSize + 1
	add ebx,2 * MapSize + 1
	add DWORD PTR [ebp - 4],4
	LOOP FILLCOL
	add esp,10h
	pop edi
	pop esi
	pop ebp
	ret
InitMap ENDP

SetMapValue PROC
	push ebp
	mov ebp,esp
	pop ebp
	ret
SetMapValue ENDP

UpdateMap PROC
	push ebp
	mov ebp,esp
	push esi
	push edi
	mov eax,offset linkListData
	mov ebx,offset linkList
	mov ecx,DWORD PTR [linkHead]
	mov esi,offset map
	TRAVERSE:
		cmp ecx,-1
		je TRAVERSECOMPLETE
		lea edx,[eax + ecx * 4]
		mov edx,DWORD PTR [edx] ; x in dx
		mov edi,edx
		sar edi,16 ; y
		push eax
		push ebx
		push ecx
		push edx
		; esi[x][y] = 2
		; x * MapSize + y
		xor eax,eax
		mov ax,dx
		mul MapSize
		pop edx
		pop ecx
		pop ebx
		pop eax
		jmp TRAVERSE
	TRAVERSECOMPLETE:
	pop ebp
	ret
UpdateMap ENDP

InsertToListHead PROC
; param1 DWORD (x,y)
	push ebp
	mov ebp,esp
	mov eax,DWORD PTR [curLinkListLength]
	mov ebx,offset linkListData
	lea ebx,[ebx + eax * 4]
	mov edx,DWORD PTR [ebp + 8]
	mov DWORD PTR [ebx],edx ; linkListData[curLinkListLength] = (x,y)
	mov ebx,offset linkList
	lea ebx,[ebx + eax * 4]
	mov edx,DWORD PTR [linkHead]
	mov DWORD PTR [ebx],edx; linkList[curLinkListLength] = linkHead
	mov DWORD PTR [linkHead],eax; linkHead = curLinkListLength
	inc eax
	mov DWORD PTR [curLinkListLength],eax; curLinkListLength++
	pop ebp
	ret
InsertToListHead ENDP

UpdateLinkList PROC
	push ebp
	mov ebp,esp
	push esi
	push edi
	sub esp,10h
	mov eax,DWORD PTR [linkHead]
	cmp eax,-1
	je UPDATECOMPLETE
	mov ebx,offset linkList
	mov ecx,offset linkListData
	mov edx,DWORD PTR [ecx + eax * 4]
	mov DWORD PTR [ebp - 4],edx ; save first node data
	UPDATE:
		mov edx,DWORD PTR [ebx + eax * 4] ; get next node
		cmp edx,-1
		je UPDATECOMPLETE
		; prevnode.data = next.data
		lea esi,[ecx + eax * 4]
		lea edi,[ecx + edx * 4]
		push eax
		push ebx
		mov eax,DWORD PTR [esi]
		mov ebx,DWORD PTR [edi]
		mov DWORD PTR [esi],ebx
		mov DWORD PTR [edi],eax
		pop ebx
		pop eax
		mov eax,edx
		jmp UPDATE
	UPDATECOMPLETE:
	mov eax,DWORD PTR [linkHead]
	mov ecx,offset linkListData
	lea ecx,[ecx + eax * 4]
	mov edx,DWORD PTR [ebp - 4]
	mov DWORD PTR [ecx],edx; restore first node data
	add esp,10h
	pop edi
	pop esi
	pop ebp
	ret
UpdateLinkList ENDP

GameLoop PROC
	push ebp
	mov ebp,esp
	call PrintMap
	pop ebp
	ret
GameLoop ENDP

Game PROC
	; col 0,31 and row 0,31 fill 1
	push ebp
	mov ebp,esp
	call InitMap
	call GameLoop
	pop ebp
	ret
Game ENDP
END